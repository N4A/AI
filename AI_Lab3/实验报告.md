14302010040_武多才

## 实验报告

### 一、算法说明

#### 基因算法

基因算法有一套公共的完整的框架，伪代码如下。

```ruby
begin
  set time t = 0 # first generation
  initGeneration() # initialize the population P(t)
  while the termination condition isnot met do
  begin
    
    fitness() # evaluate fitness of each member of the population P(t);
    select() # select members from population P(t) based on fitness;
    
    # produce the offspring of these pairs using genetic operators(cross,mutate);
    # replace candidates of P(t), with these offspring;
    cross() #
    mutate() #
    
    set time t = t + 1 # new generation
  end
end
```

结合以上代码来分析一下基因算法：

1. 第3行，首先要初始化第一代种群。这里涉及到一个个体是如何编码的，这一点对于不同的具体问题，要做出不同的实现。
2. 第4~16行，在终止条件到来之前，种群一代代循环进化，具体如下：
   1. 第7行，计算种群个体的适应度，这里可以评估最优秀个体和平均适应度等。这一点上适应度对于不同的具体问题，其个体适应度计算方法不同，要做出不同实现。
   2. 第8行，根据个体的适应度不同，选出优秀的个体。这一点有多种不同的策略，例如轮盘赌策略和随机二选一的策略。
   3. 12~13行，选出优秀的个体之后，我们要用这些个体产生新一代的种群。具体方法则是交叉和变异。这里有两点需注意，一是交叉或变异的个体的选择有多种不同的策略，二是针对于不同的具体问题，交叉或变异的具体方法不同。
   4. 第15行，经过以上操作产生了新的一代，在这里做出标记。
3. 当达到终止条件时，则结束进化。

####  代码设计

根据上述描述分析可以看出，基因算法有一套公用的框架。但有两点值得注意，一是选择，交叉，变异的个体选择有多种不同的策略；二是针对于不同的具体问题，个体的基因编码、交叉和变异的具体方式可能不同。所以在设计框架时，要为这两点留出余地，以便：1. 方便复用代码扩展新策略的基因算法，2. 复用代码实现针对于具体问题的基因算法。

设计图如下：

![基因算法设计图](genetic.PNG)

如设计图所示，GeneralGeneticAlgorithm已经实现了基因算法的基本框架，选择，交叉，变异的个体选择都有默认实现。

	1. 其默认的选择个体的策略时轮盘赌的策略。
	2. 默认的交叉是以一定概率挨个询问个体是否交叉，凑够两个时将两个个体进行交叉。
	3. 默认的变异是以一定概率挨个询问个体是否要变异。

其次使用该框架时，必须传入一个继承IGeneticAssistant接口的assistant，assistant决定个体的编码，交叉和变异方式。

使用如下：

```java
IGeneticAssistant assistant = new BasicKnapSack(); //以背包问题为例
GeneralGeneticAlgorithm algorithm = 
			new GeneralGeneticAlgorithm(iterationMax, scale,
			assistant, crossP, mutateP);//其他参数是迭代次数，种群规模，交叉概率，变异概率

algorithm.start(true); //调用此函数开始迭代，true表示迭代过程中打印出每代信息

// 结束后可以取出最好的个体
System.out.println(algorithm.getBestIndividual().toString());
```

然后也可以继承GeneralGeneticAlgorithm复用代码来实现新策略的基因算法，如图SequenceCross和RandomCross都是复写了父类cross算法，采用不通的策略来选择要交叉的个体。

#### 背包问题

这时候解决背包问题就简单了，只要实现IGeneticAssistant决定个体的编码，适应度评估，交叉，变异和拷贝方式。如上设计图所示的BasicKnapsack类采用如下具体设计。

1. 个体编码：用一个byte数组表示DNA，个体DNA的长度就是所有物品的数目，然后每一个位置的基因设置为0或1，表示不拿或拿当前的物品
2. 适应度评估：评估方式很简单，就是将选择的个体的价值都加起来，作为适应度；但如果其总重量超过背包容量，就将其适应度置为0（为防止小概率的种群总适应度为0的情况，可以将此适应度置为接近0，如1e-10）
3. 交叉：交叉方式是随机选一个起点和终点，然后将两个个体在起点和终点之间的基因段进行交换。
4. 变异：变异方式是随机选一个起点和终点，然后将该个体在起点和终点之间的基因段中0变1，1变0
5. 拷贝：由于编码采用数组，所以复制产生新个体时，要将数组中每个值都拷贝一份，才能避免使用相同地址空间。

然后设计图中RandomCrossMute复写交叉和变异的方法：

1. 交叉：随机生成要改变基因数，然后挑选随机位置的基因进行互换。
2. 变异：随机生成要改变基因数，然后挑选随机位置的基因0，1倒置。

设计图中的SequenceCrossMute顾名思义就是沿用了默认的方法，将其单独写出来，只是使得结构清新一点。

扩展其它策略的便签是指也可以继承BasicKnapsack来复写特定方法更改策略。

#### 旅行商问题

旅行商问题也是要实现IGeneticAssistant决定个体的编码，评估，交叉，变异和拷贝方式。如上设计图所示的BasicTSP类采用如下具体设计(首先将所有地点存在一个数组里)。

1. 个体编码：用一个int数组表示DNA，DNA是地点访问顺序的一个序列，也就地点数组下标的一个序列。

2. 适应度评估：首先计算出旅行商按该个体DNA序列出发再回到起点的总路程，取其倒数作为适应度。也就是距离越短适应度越高

3. 交叉：交叉的方式比教复杂，举个列子：

   ```java
   // 这是为交叉之前的两个DNA序列，先随机选取两个点将其分成三份。
   p1 = ( 1 9 2 | 4 6 5 7 | 8 3 )
   p2 = ( 4 5 9 | 1 8 7 6 | 2 3 )
   // 然后将p2从第三部分开始得到临时的新序列tmp2
   tmp2 = 2 3 4 5 9 1 8 7 6
   // 这时候p1的三部分中的中间那部分（记为p12）保持不动，
   // 然后将第一部分和第三部分依此用tmp2中不在p12区间内的元素替换
   // 然后就可以得到p1交叉后的结果c2
   c1 = ( 2 3 9 | 4 6 5 7 | 1 8 )
   // 同样，也可以得到p2交叉后的c2
   c2 = ( 3 9 2 | 1 8 7 6 | 4 5 )
   ```

4. 变异：变异比较简单，举个列子：

   ```java
   // 同样将待变异p1随机分成三部分
   p1 = ( 1 9 2 | 4 6 5 7 | 8 3 )
   // 然后将中间部分颠倒顺序就得到变异后的c1
   c1 = ( 1 9 2 | 7 5 6 4 | 8 3 )
   ```

5. 拷贝：由于编码采用数组，所以复制产生新个体时，要将数组中每个值都拷贝一份，才能避免使用相同地址空间。

最后扩展其它策略的便签是指也可以继承BasicTSP来复写特定方法更改策略，我没有实现其它策略。

### 二、实验分析

